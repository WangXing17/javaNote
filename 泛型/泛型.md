# 泛型

## 一、泛型类
### 定义: 就是具有一个或多个类型变量的类。
```
//定义
public class MyGeneric<T, U> {

    private T name;
    private U code;

    public T getName() {return name;}

    public U getCode() {return code;}

    public void setName(T name) {this.name = name;}
    
    public void setCode(U code) {this.code = code;}

    public MyGeneric() {this.name = null; this.name = null;}

    public MyGeneric(T name, U code) {this.name = name; this.code = code;}
}

//调用
MyGeneric<String, Integer> myGeneric = new MyGeneric<>();
```

MyGeneric类引人了两个类型变量 T, U, 用尖括号 (< >) 括起来，并放在类名的后面。


## 二、泛型接口
### 定义:  就是具有一个或多个类型变量的接口。
```
//定义
public interface GInterface<T, U> {
    T method1();
    U method2();
}

//调用
public class GInterfaceImpl<T, U> implements GInterface<T, U> {
    
    @Override
    public T method1() {return null;}

    @Override
    public U method2() {return null;}

    public static void main(String[] args) {
        GInterface<String, Integer> gInterface = new GInterfaceImpl<String, Integer>();
    }
}
```

## 三、泛型方法
### 定义：就是具有一个或多个类型变量的方法。
```
//定义
public <T> void gMethod(T t){
    System.out.println(t);
}

//调用

```

## 四、泛型通配符
### 1. 常用的 T，E，K，V，？
本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的T ，我们可以换成 A-Z 之间的任何一个字母都可以，并不会影响程序的正常运行。通常情况下，T，E，K，V，？是这样约定的：
* 类型变量E表示集合的元素类型。
* 类型变量K和V分别表示表的键与值的类型。
* 类型变量T(需要时还可以用临近的字母 U 和 S) 表示“任意类型”。
* 类型变量？也表示任意类型

### 2. ？无界通配符
使用无边界通配符可以让泛型接收任意类型的数据

### 3. 上界通配符 < ? extends T>
表示类型的上界，表示参数化类型的可能是T 或是 T的子类。这里的T可以是类也可以是接口
```
public class MyGeneric<T> {

    private T name;

    public T getName() { return name; }

    public void setName(T name) { this.name = name; }

    public MyGeneric() { this.name = null; }

    public MyGeneric(T name) { this.name = name; }

    public static void main(String[] args) {
        //A1 为 A 的子类
        MyGeneric<? extends A> myGeneric = new MyGeneric<A>();
        MyGeneric<? extends A> myGeneric1 = new MyGeneric<A1>();

        //编译出错，类型限定上界为A，只能接受A和A的子类。其余类型则报错。
        MyGeneric<? extends A> myGeneric2 = new MyGeneric<Object>();
    }
}
```


### 4. 下界通配符 < ? super T>
表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object
```
public class MyGeneric<T> {

    private T name;

    public T getName() { return name; }

    public void setName(T name) { this.name = name; }

    public MyGeneric() { this.name = null; }

    public MyGeneric(T name) { this.name = name; }

    public static void main(String[] args) {
        //A1 为 A 的子类
        MyGeneric<? super A> myGeneric = new MyGeneric<A>();
        MyGeneric<? super A> myGeneric2 = new MyGeneric<Object>();

        //编译出错，类型限定下界为A，只能接受A和A的父类。其余类型则报错。
        MyGeneric<? super A> myGeneric1 = new MyGeneric<A1>();
    }
}
```

### 5. ？和 T 的区别


